class MoveChannel {
  boolean transfering;
  Move exchangeValue;
  Player s,r; // Sending, receiving player

  resource lock_invariant() = channelAnnotations();

  inline resource channelAnnotations() = true
    ** Perm(transfering, 1) ** Perm(exchangeValue, 1)
    ** Perm(s, 1\2) ** s != null
    ** Perm(r, 1\2) ** r != null
    ** (transfering ==> true
        ** exchangeValue.movePerm()
        ** ([1\2]s.boardPerm())
        ** ([1\2]r.boardPerm())
        ** s.oneMoveAheadOf(exchangeValue, r)
        ** ([1\2]s.returneeBound(r))
        ** ([1\2]s.returneeToken())
        ** (!s.gameFinished() ==> ([1\2]s.returneeToken()))
        )
    ;

  requires s != null ** r != null;
  ensures Perm(this.s, 1\2) ** Perm(this.r, 1\2);
  ensures this.s == s ** this.r == r;
  MoveChannel(Player s, Player r) {
    transfering = false;
    this.s = s;
    this.r = r;
  }

  context Perm(s, 1\8) ** Perm(r, 1\8);
  requires v.movePerm();
  requires [1\2]s.boardPerm();
  requires [1\2]r.boardPerm();
  requires s.oneMoveAheadOf(v, r);
  requires ([1\2]s.returneeBound(r));
  requires ([1\2]s.returneeToken());
  requires !s.gameFinished() ==> ([1\2]s.returneeToken());
  void writeValue(Move v) {
    lock this;
    loop_invariant held(this);
    loop_invariant channelAnnotations();
    while(!transfering) {
      wait this;
    }
    transfering = true;
    exchangeValue = v;
    unlock this;
  }

  context Perm(s, 1\8) ** Perm(r, 1\8);
  ensures \result.movePerm();
  ensures [1\2]s.boardPerm();
  ensures [1\2]r.boardPerm();
  ensures s.oneMoveAheadOf(\result, r);
  ensures ([1\2]s.returneeBound(r));
  ensures ([1\2]s.returneeToken());
  ensures !s.gameFinished() ==> ([1\2]s.returneeToken());
  Move readValue(){
    lock this;
    loop_invariant held(this);
    loop_invariant channelAnnotations();
    while(!transfering){
      wait this;
    }
    Move v = exchangeValue;
    transfering = false;
    unlock this;
    return v;
  }

}

class PlayerThread {

    Player p;
    Player other;
    MoveChannel writeMoveChan;
    MoveChannel readMoveChan;

    requires token == 0 || token == 1;
    ensures threadPerm();
    ensures ([1\2]p.boardPerm());
    ensures p.emptyBoard();
    ensures p.myToken == token;
    ensures p.turn == turn;
    ensures Perm(p.returnee, 1);
    ensures Perm(other, 1\2);
    ensures Perm(p, 1\2);
    ensures Perm(p.myToken, 1\2);
    PlayerThread(int token, boolean turn) {
        p = new Player(token, turn);
    }

    inline resource threadPerm() = true
      ** Perm(p, 1\2) ** ([1\2]p.boardPerm())
      ** Perm(p.move, write) ** Perm(p.turn, write) ** Perm(other, 1\2)
      ** Perm(p.myToken, 1\2) ** (p.myToken == 0 || p.myToken == 1)
      ** Perm(writeMoveChan, write) ** Perm(readMoveChan, write)
      ;

    inline resource chanPerm() = true
      ** Perm(writeMoveChan.s, 1\4) ** Perm(writeMoveChan.r, 1\4)
      ** Perm(readMoveChan.s, 1\4) ** Perm(readMoveChan.r, 1\4)
      ** writeMoveChan.s == this.p ** readMoveChan.r == this.p
      ** other == writeMoveChan.r ** writeMoveChan.r == readMoveChan.s
      ;

    inline resource turnPerm() = true
      ** ([1\2]p.boardPerm()) ** ([1\2]other.boardPerm())
      ** p.equalBoard(other)
      ;

    context threadPerm() ** chanPerm();
    requires p.emptyBoard();
    context [1\4]p.returneeBound(other);
    requires p.turn ==> turnPerm() ** ([1\2]p.returneeBound(other)) ** p.returneeToken();
    ensures p.gameFinished();
    ensures (([1\2]p.returneeToken()) ** (p.returnee.token == p.myToken ==> turnPerm()));
    void run() {
        loop_invariant threadPerm() ** chanPerm();
        loop_invariant [1\4]p.returneeBound(other);
        loop_invariant p.turn && !p.gameFinished() ==>
          turnPerm()
          ** ([1\2]p.returneeBound(other))
          ** p.returneeToken();
        loop_invariant p.gameFinished() ==>
          (([1\2]p.returneeToken()) **
          (p.returnee.token == p.myToken ==> turnPerm()));
        while (!p.gameFinished()) /* decreases */ {
            // int x = p.fieldSize() - p.countMoves()
            if (p.turn) {
                p.createNewMove();
                p.doMove();
                if (p.gameFinished()) {
                  p.returnee.token = 1 - p.myToken;
                }
                writeMoveChan.writeValue(p.move.copy());
            } else {
                p.move = readMoveChan.readValue();
                p.doMove();
            }
            // assert x > p.fieldSize() - p.countMoves();
            p.turn = !p.turn;
        }
    }
}

class MainFJ {
    static void mainFJ() {
        PlayerThread p1 = new PlayerThread(0,true);
        PlayerThread p2 = new PlayerThread(1,false);

        p1.other = p2.p;
        p2.other = p1.p;

        p1.p.returnee = new Returnee();
        p2.p.returnee = p1.p.returnee;
        p1.p.returnee.token = 0;

        MoveChannel p1p2MoveChan = new MoveChannel(p1.p, p2.p);
        MoveChannel p2p1MoveChan = new MoveChannel(p2.p, p1.p);

        p1.writeMoveChan = p1p2MoveChan;
        p1.readMoveChan = p2p1MoveChan;
        p2.writeMoveChan = p2p1MoveChan;
        p2.readMoveChan = p1p2MoveChan;

        fork p1;
        fork p2;
        join p1;
        join p2;

        assert p1.p.equalBoard(p2.p);
    }
}
