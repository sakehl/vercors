adt `block` {
  pure int block_length(`block` b);
  pure ref loc(`block` b, int i);
  pure int block_address(`block` b);

  pure `block` loc_inv_1(ref r);
  pure int loc_inv_2(ref r);

  pure `block` addr_inv(int address);

  // block length is non-negative
  axiom (\forall `block` b; block_length(b) >= 0);

  // loc is injective: a (block, index) pair indicates a unique ref
  axiom (∀ `block` b, int i; loc_inv_1({:loc(b, i):}) == b && loc_inv_2(loc(b, i)) == i);

  // a block must be based higher than 0
  axiom (∀ `block` b; {:block_address(b):} > 0);

  // every block is uniquely identified by an address
  axiom (∀ `block` b; addr_inv({:block_address(b):}) == b);
}

adt `pointer` {
  pure `pointer` pointer_of(`block` b, int offset);
  pure `block` pointer_block(`pointer` p);
  pure int pointer_offset(`pointer` p);
  pure `pointer` pointer_inv(ref r);

  // the block offset is valid wrt the length of the block
  axiom (∀ `pointer` p;
    pointer_offset(p) >= 0 &&
      pointer_offset(p) < `block`.block_length(pointer_block(p)));

  // pointer_of is injective: a (block, offset) pair indicates a unique pointer value
  axiom (∀`block` b, int offset;
    {:1:pointer_block(pointer_of(b, offset)):} == b &&
      {:2:pointer_offset(pointer_of(b, offset)):} == offset);

  axiom (∀ ref r; ptr_deref({:pointer_inv(r):}) == r);

  axiom (∀ `pointer` p; pointer_inv({:ptr_deref(p):}) == p);

  axiom ptr_add_axiom();
}


decreases;
pure ref ptr_deref(`pointer` p) =
  `block`.loc(`pointer`.pointer_block(p), `pointer`.pointer_offset(p));

decreases;
requires 0 <= `pointer`.pointer_offset(p) + offset;
requires `pointer`.pointer_offset(p) + offset < `block`.block_length(`pointer`.pointer_block(p));
ensures \polarity_dependent(offset == 0 ==> \result == p, true);
pure `pointer` ptr_add(`pointer` p, int offset) =
  `pointer`.pointer_of(
     `pointer`.pointer_block(p),
     `pointer`.pointer_offset(p) + offset);

decreases;
ensures (\forall `pointer` p1, int offset, int i;
    0 <= `pointer`.pointer_offset(p1) + offset &&
    `pointer`.pointer_offset(p1) + offset < `block`.block_length(`pointer`.pointer_block(p1)) &&
    0 <= i &&
    i < `block`.block_length(`pointer`.pointer_block(p1)) - `pointer`.pointer_offset(p1) - offset;
    {:ptr_add(ptr_add(p1, offset), i):} == ptr_add(p1, offset + i));
pure boolean ptr_add_axiom() = true;

// TODO: Do we want to support zero-sized types? (i.e. stride == 0)
decreases assume;
requires stride > 0;
ensures \result > 0;
ensures \polarity_dependent(ptr_from_address(\result, stride) == p, true);
pure int ptr_address(`pointer` p, int stride) = `block`.block_address(`pointer`.pointer_block(p)) + (`pointer`.pointer_offset(p) * stride);

decreases assume;
requires address > 0;
requires stride > 0;
ensures ptr_address(\result, stride) == address;
pure `pointer` ptr_from_address(int address, int stride);
