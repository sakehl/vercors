/*
This version is based on tic-tac-toe-board6.

It tries to get rid of the returneeToken by "just" sending a game end message. This message is used to unequally/asymmetrically, _but_ deterministically, distribute the permissions. Because the permissions are deterministically distributed, it is trivial to prove that full permission to the boards is regained after termination of both threads.

Interesting: two channels are needed for one game end message, even though we will only use _one_ of them _once_.
*/

lock_invariant channelAnnotations();
class MoveChannel {
  boolean transfering;
  Move exchangeValue;
  Player s,r; // Sending, receiving player


  inline resource channelAnnotations() = true
    ** Perm(transfering, 1) ** Perm(exchangeValue, 1)
    ** Perm(s, 1\2) ** s != null
    ** Perm(r, 1\2) ** r != null
    ** (transfering ==> true
        ** exchangeValue.movePerm()
        ** ([1\2]s.boardPerm())
        ** ([1\2]r.boardPerm())
        ** s.oneMoveAheadOf(exchangeValue, r)
        )
    ;

  requires s != null ** r != null;
  ensures committed(this);
  ensures Perm(this.s, 1\2) ** Perm(this.r, 1\2);
  ensures this.s == s ** this.r == r;
  constructor(Player s, Player r) {
    transfering = false;
    this.s = s;
    this.r = r;
    commit this;
  }

  context_everywhere committed(this);
  context Perm(s, 1\8) ** Perm(r, 1\8);
  requires v.movePerm();
  requires [1\2]s.boardPerm();
  requires [1\2]r.boardPerm();
  requires s.oneMoveAheadOf(v, r);
  void writeValue(Move v) {
    lock this;
    loop_invariant held(this);
    loop_invariant channelAnnotations();
    while(!transfering) {
      wait this;
    }
    transfering = true;
    exchangeValue = v;
    unlock this;
  }

  context_everywhere committed(this);
  context Perm(s, 1\8) ** Perm(r, 1\8);
  ensures \result.movePerm();
  ensures [1\2]s.boardPerm();
  ensures [1\2]r.boardPerm();
  ensures s.oneMoveAheadOf(\result, r);
  Move readValue(){
    lock this;
    loop_invariant held(this);
    loop_invariant channelAnnotations();
    while(!transfering){
      wait this;
    }
    Move v = exchangeValue;
    transfering = false;
    unlock this;
    return v;
  }

}

lock_invariant channelAnnotations();
class GameEndChannel {
  boolean transfering;
  int exchangeValue;
  Player s,r; // Sending, receiving player

  inline resource channelAnnotations() = true
    ** Perm(transfering, 1) ** Perm(exchangeValue, 1)
    ** Perm(s, 1\2) ** s != null
    ** Perm(r, 1\2) ** r != null
    ** (transfering ==> true
        ** exchangeValue == 0 // We can only send a meaningless value
        ** ([3\4]s.boardPerm())
        ** ([1\4]r.boardPerm())
        ** s.equalBoard(r)
        )
    ;

  requires s != null ** r != null;
  ensures committed(this);
  ensures Perm(this.s, 1\2) ** Perm(this.r, 1\2);
  ensures this.s == s ** this.r == r;
  constructor(Player s, Player r) {
    transfering = false;
    this.s = s;
    this.r = r;
    commit this;
  }

  context_everywhere committed(this);
  context Perm(s, 1\8) ** Perm(r, 1\8);
  requires [1\4]s.boardPerm();
  requires [1\4]r.boardPerm();
  requires s.equalBoard(r);
  requires v == 0;
  void writeValue(int v) {
    lock this;
    loop_invariant held(this);
    loop_invariant channelAnnotations();
    while(!transfering) {
      wait this;
    }
    transfering = true;
    exchangeValue = v;
    unlock this;
  }

  context Perm(s, 1\8) ** Perm(r, 1\8);
  requires committed(this);
  ensures [1\4]s.boardPerm();
  ensures [1\4]r.boardPerm();
  ensures s.equalBoard(r);
  ensures \result == 0;
  int readValue(){
    lock this;
    loop_invariant held(this);
    loop_invariant channelAnnotations();
    while(!transfering){
      wait this;
    }
    int v = exchangeValue;
    transfering = false;
    unlock this;
    return v;
  }

}

class PlayerThread {

    Player p;
    Player other;
    MoveChannel writeMoveChan;
    MoveChannel readMoveChan;
    GameEndChannel writeGameEndChan;
    GameEndChannel readGameEndChan;

    requires token == 0 || token == 1;
    ensures idle(this);
    ensures threadPerm();
    ensures ([1\2]p.boardPerm());
    ensures p.emptyBoard();
    ensures p.myToken == token;
    ensures p.turn == turn;
    ensures Perm(other, 1\2);
    ensures Perm(p, 1\2);
    ensures Perm(p.myToken, 1\2);
    constructor(int token, boolean turn) {
        p = new Player(token, turn);
    }

    inline resource threadPerm() = true
      ** Perm(p, 1\2) ** ([1\2]p.boardPerm())
      ** Perm(p.move, write) ** Perm(p.turn, write) ** Perm(other, 1\2)
      ** Perm(p.myToken, 1\2) ** (p.myToken == 0 || p.myToken == 1)
      ** Perm(writeMoveChan, write) ** Perm(readMoveChan, write)
      ** Perm(writeGameEndChan, write) ** Perm(readGameEndChan, write)
      ;

    inline resource chanPerm() = true
      ** Perm(writeMoveChan.s, 1\4) ** Perm(writeMoveChan.r, 1\4)
      ** Perm(readMoveChan.s, 1\4) ** Perm(readMoveChan.r, 1\4)
      ** Perm(writeGameEndChan.s, 1\4) ** Perm(writeGameEndChan.r, 1\4)
      ** Perm(readGameEndChan.s, 1\4) ** Perm(readGameEndChan.r, 1\4)
      ** committed(writeMoveChan) ** committed(readMoveChan) ** committed(writeGameEndChan) ** committed(readGameEndChan)
      ** writeMoveChan.s == this.p ** readMoveChan.r == this.p ** writeGameEndChan.s == this.p ** readGameEndChan.r == this.p
      ** writeMoveChan.r == other  ** readMoveChan.s == other  ** writeGameEndChan.r == other  ** readGameEndChan.s == other
      ;

    inline resource turnPerm() = true
      ** ([1\2]p.boardPerm()) ** ([1\2]other.boardPerm())
      ** p.equalBoard(other)
      ;

    context threadPerm() ** chanPerm();
    requires p.emptyBoard();
    requires p.turn ==> turnPerm();
    ensures p.gameFinished();
    ensures ([1\4]p.boardPerm()) ** ([1\4]other.boardPerm()) ** p.equalBoard(other);
    run {
        loop_invariant threadPerm() ** chanPerm();
        loop_invariant p.turn && !p.gameFinished() ==> turnPerm();
        loop_invariant p.turn && p.gameFinished() ==> turnPerm();
        while (!p.gameFinished()) {
            if (p.turn) {
                p.createNewMove();
                p.doMove();
                writeMoveChan.writeValue(p.move.copy());
            } else {
                p.move = readMoveChan.readValue();
                p.doMove();
            }
            p.turn = !p.turn;
        }

        if (p.turn) {
          writeGameEndChan.writeValue(0);
        } else {
          readGameEndChan.readValue();
        }

        assert ([3\4]p.boardPerm()) ** ([1\4]other.boardPerm()) ** p.equalBoard(other);
    }
}

void mainFJ() {
    PlayerThread p1 = new PlayerThread(0,true);
    PlayerThread p2 = new PlayerThread(1,false);

    p1.other = p2.p;
    p2.other = p1.p;

    MoveChannel p1p2MoveChan = new MoveChannel(p1.p, p2.p);
    MoveChannel p2p1MoveChan = new MoveChannel(p2.p, p1.p);

    p1.writeMoveChan = p1p2MoveChan;
    p1.readMoveChan = p2p1MoveChan;
    p2.writeMoveChan = p2p1MoveChan;
    p2.readMoveChan = p1p2MoveChan;

    GameEndChannel p1p2GameEndChan = new GameEndChannel(p1.p, p2.p);
    GameEndChannel p2p1GameEndChan = new GameEndChannel(p2.p, p1.p);

    p1.writeGameEndChan = p1p2GameEndChan;
    p1.readGameEndChan = p2p1GameEndChan;
    p2.writeGameEndChan = p2p1GameEndChan;
    p2.readGameEndChan = p1p2GameEndChan;

    fork p1;
    fork p2;
    join p1;
    join p2;

    // Yay!
    assert true
      ** p1.p.boardPerm() ** p2.p.boardPerm()
      ** p1.p.equalBoard(p2.p)
      ;
}
