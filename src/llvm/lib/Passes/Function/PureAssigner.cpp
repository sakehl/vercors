#include "Passes/Function/PureAssigner.h"

#include "Passes/Function/FunctionDeclarer.h"
#include "Util/Constants.h"
#include "Util/Exceptions.h"
#include "Util/PallasMD.h"

#include <llvm/IR/Constants.h>

namespace pallas {
const std::string SOURCE_LOC = "Passes::Function::PureAssigner";

using namespace llvm;

/**
 * Helper function to generate errors generated by this Pass
 * @param F
 * @param explanation
 */
static void reportError(Function &F, const std::string &explanation) {
    std::stringstream errorStream;
    errorStream << "Malformed Metadata node of type \""
                << pallas::constants::METADATA_PURE_KEYWORD
                << "\":" << explanation;
    pallas::ErrorReporter::addError(SOURCE_LOC, errorStream.str(), F);
}

PreservedAnalyses PureAssignerPass::run(Function &F,
                                        FunctionAnalysisManager &FAM) {
    // Count how many annotation specify the purity of the function.
    int pureAnnotationCount = 0;
    bool isPure = false;

    // Check if the function is annotated with the pure-metadata of VCLLVM
    if (F.hasMetadata(pallas::constants::METADATA_PURE_KEYWORD)) {
        pureAnnotationCount++;
        MDNode *pureMDNode =
            F.getMetadata(pallas::constants::METADATA_PURE_KEYWORD);
        if (!isVcllvmPureWellformed(*pureMDNode, F))
            return PreservedAnalyses::all();
        // attempt down cast to ConstantInt (should workdue to previous checks)
        auto *pureMDVal = cast<ValueAsMetadata>(pureMDNode->getOperand(0));
        isPure = cast<ConstantAsMetadata>(pureMDVal)->getValue()->isOneValue();
    }

    // Check if the function is annotated with a pallas function contract
    if (F.hasMetadata(pallas::constants::PALLAS_FUNC_CONTRACT)) {
        pureAnnotationCount++;
        MDNode *contractMDNode =
            F.getMetadata(pallas::constants::PALLAS_FUNC_CONTRACT);
        if (!isPallasPureWellformed(*contractMDNode, F))
            return PreservedAnalyses::all();
        // Extract pure-value (should work due to previous checks)
        isPure = getPureValueFromPallasContract(*contractMDNode);
    }

    // Check if the function is marked as a pallas wrapper-function
    if (utils::isPallasExprWrapper(F)) {
        pureAnnotationCount++;
        isPure = true;
    }

    // Check that no duplicate pure-definition is present
    if (pureAnnotationCount > 1) {
        reportError(F,
                    "Function has multiple annotations that speciy its purity");
        return PreservedAnalyses::all();
    }

    // Set the pure-flag of the function
    FDResult result = FAM.getResult<FunctionDeclarer>(F);
    col::LlvmFunctionDefinition &colFunction = result.getAssociatedColFuncDef();
    colFunction.set_pure(isPure);
    return PreservedAnalyses::all();
}

bool PureAssignerPass::isVcllvmPureWellformed(MDNode &pureMD, Function &f) {
    std::ostringstream errorStream;
    // check if the 'pure' metadata has only 1 operand, else exit with error
    if (pureMD.getNumOperands() != 1) {
        errorStream << "Expected 1 argument but got "
                    << pureMD.getNumOperands();
        reportError(f, errorStream.str());
        return false;
    }
    // check if the only operand is of type 'i1', else exit with error
    auto *pureMDValue = cast<ValueAsMetadata>(pureMD.getOperand(0));
    if (!pureMDValue->getType()->isIntegerTy(1)) {
        errorStream << "MD node type must be of type \"i1\"";
        reportError(f, errorStream.str());
        return false;
    }
    return true;
}

bool PureAssignerPass::isPallasPureWellformed(MDNode &contractMD, Function &f) {
    std::ostringstream errorStream;
    // Check that the contract has at least 2 operands
    if (contractMD.getNumOperands() < 2) {
        reportError(f, "Ill-formed contract. Expected at least 2 operands");
        return false;
    }
    // Check that the second operand is a boolean constant
    auto *pureConst =
        dyn_cast<ConstantAsMetadata>(contractMD.getOperand(1).get());
    auto *pureVal = dyn_cast_if_present<ConstantInt>(pureConst->getValue());
    if (pureVal == nullptr || (!pureVal->getBitWidth() == 1)) {
        reportError(f, "Ill-formed contract. Second operand should be boolean");
        return false;
    }
    return true;
}

bool PureAssignerPass::getPureValueFromPallasContract(MDNode &contractMD) {
    auto *pureConst = cast<ConstantAsMetadata>(contractMD.getOperand(1).get());
    auto *pureVal = cast<ConstantInt>(pureConst->getValue());
    return pureVal->isOne();
}

} // namespace pallas
