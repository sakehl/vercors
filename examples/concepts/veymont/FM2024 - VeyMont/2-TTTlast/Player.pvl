class Returner {
  int mark;
}

class Player {

  int c00, c01, c02, c10, c11, c12, c20, c21, c22;
  int myMark;
  Move move;
  boolean turn;
  Returner returner;
  
  inline resource boardPerm() = 
      Perm(c00, 1) ** Perm(c01, 1) ** Perm(c02, 1) ** 
      Perm(c10, 1) ** Perm(c11, 1) ** Perm(c12, 1) ** 
      Perm(c20, 1) ** Perm(c21, 1) ** Perm(c22, 1);

  inline resource returnerBound(Player other) = true
    ** Perm(returner, write)
    ** Perm(other.returner, write)
    ** returner == other.returner
    ;

  inline resource returnerMark() = true
    ** Perm(returner.mark, write) 
    ** (returner.mark == 0 || returner.mark == 1)
    ;

  requires [1\2]boardPerm();
  pure boolean emptyBoard() = 
    c00 == -1 && c01 == -1 && c02 == -1 && 
    c10 == -1 && c11 == -1 && c12 == -1 && 
    c20 == -1 && c21 == -1 && c22 == -1;

  requires tok == 0 || tok == 1;
  ensures boardPerm();
  ensures emptyBoard();
  ensures Perm(myMark, write);
  ensures Perm(move, 1);
  ensures move.state();
  ensures myMark == tok;
  ensures myMark == 0 || myMark == 1;
  ensures Perm(turn, 1) ** turn == t;
  ensures Perm(returner, 1);
  constructor(int tok, boolean t) {
    c00 = -1;
    c01 = -1;
    c02 = -1;
    c10 = -1;
    c11 = -1;
    c12 = -1;
    c20 = -1;
    c21 = -1;
    c22 = -1;
    myMark = tok;
    turn = t;
    move = new Move(0, 0, 0);
  }

  requires tok == 0 || tok == 1;
  requires Perm(other.returner, 1);
  ensures boardPerm();
  ensures emptyBoard();
  ensures Perm(myMark, write);
  ensures Perm(move, 1);
  ensures move.state();
  ensures myMark == tok;
  ensures myMark == 0 || myMark == 1;
  ensures Perm(turn, 1) ** turn == t;
  ensures returnerBound(other) ** returnerMark();
  constructor(int tok, boolean t, Player other) {
    c00 = -1;
    c01 = -1;
    c02 = -1;
    c10 = -1;
    c11 = -1;
    c12 = -1;
    c20 = -1;
    c21 = -1;
    c22 = -1;
    myMark = tok;
    turn = t;
    move = new Move(0, 0, 0);

    returner = new Returner();
    returner.mark = 0;
    other.returner = returner;

    fold returnerBound(other);
    fold returnerMark();
  }

  requires ([1\100]boardPerm()) ** ([1\100]other.boardPerm());
  requires Perm(move.i, read) ** Perm(move.j, read) ** Perm(move.mark, read);
  requires 0 <= move.i && move.i <= 2;
  requires 0 <= move.j && move.j <= 2;
  pure boolean oneMoveAheadOf(Move move, Player other) = 
    readMoveCell(move,this) == move.mark && readMoveCell(move,other) == -1
    && (move.i != 0 || move.j != 0 ==> other.c00 == c00)
    && (move.i != 0 || move.j != 1 ==> other.c01 == c01)
    && (move.i != 0 || move.j != 2 ==> other.c02 == c02)
    && (move.i != 1 || move.j != 0 ==> other.c10 == c10)
    && (move.i != 1 || move.j != 1 ==> other.c11 == c11)
    && (move.i != 1 || move.j != 2 ==> other.c12 == c12)
    && (move.i != 2 || move.j != 0 ==> other.c20 == c20)
    && (move.i != 2 || move.j != 1 ==> other.c21 == c21)
    && (move.i != 2 || move.j != 2 ==> other.c22 == c22);
  
  context boardPerm();
  context Perm(move,1\2) ** ([1\2]move.state());
  requires readMoveCell(move,this) == -1;
  ensures readMoveCell(move,this) == move.mark;
  ensures move.i != 0 || move.j != 0 ==> \old(c00) == c00;
  ensures move.i != 0 || move.j != 1 ==> \old(c01) == c01;
  ensures move.i != 0 || move.j != 2 ==> \old(c02) == c02;
  ensures move.i != 1 || move.j != 0 ==> \old(c10) == c10;
  ensures move.i != 1 || move.j != 1 ==> \old(c11) == c11;
  ensures move.i != 1 || move.j != 2 ==> \old(c12) == c12;
  ensures move.i != 2 || move.j != 0 ==> \old(c20) == c20;
  ensures move.i != 2 || move.j != 1 ==> \old(c21) == c21;
  ensures move.i != 2 || move.j != 2 ==> \old(c22) == c22;      
  void doMove() {
    if(move.i == 0 && move.j == 0) {
      c00 = move.mark;
    } else if(move.i == 0 && move.j == 1) {
      c01 = move.mark;
    } else if(move.i == 0 && move.j == 2) {
      c02 = move.mark;
    } else if(move.i == 1 && move.j == 0) {
      c10 = move.mark;
    } else if(move.i == 1 && move.j == 1) {
      c11 = move.mark;
    } else if(move.i == 1 && move.j == 2) {
      c12 = move.mark;
    } else if(move.i == 2 && move.j == 0) {
      c20 = move.mark;
    } else if(move.i == 2 && move.j == 1) {
      c21 = move.mark;
    } else if(move.i == 2 && move.j == 2) {
      c22 = move.mark;
    }
  }

  requires [1\100]boardPerm();
  pure boolean boardFull() =
    c00 != -1 && c01 != -1 && c02 != -1 && 
    c10 != -1 && c11 != -1 && c12 != -1 && 
    c20 != -1 && c21 != -1 && c22  != -1;
    
  requires [1\100]boardPerm();
  pure boolean boardWin() =
    c00 != -1 && c00 == c01 && c01 == c02 ||
    c10 != -1 && c10 == c11 && c11 == c12 ||
    c20 != -1 && c20 == c21 && c21 == c22 ||
    c00 != -1 && c00 == c10 && c10 == c20 ||
    c01 != -1 && c01 == c11 && c11 == c21 ||
    c02 != -1 && c02 == c12 && c12 == c22 ||
    c00 != -1 && c00 == c11 && c11 == c22 ||
    c02 != -1 && c02 == c11 && c11 == c20;
    
  requires [1\100]boardPerm();
  pure boolean gameFinished() = boardFull() || boardWin();
  
  requires [1\100]boardPerm();
  requires [1\100]other.boardPerm();
  pure boolean equalBoard(Player other) =
    c00 == other.c00 && c01 == other.c01 && c02 == other.c02 && 
    c10 == other.c10 && c11 == other.c11 && c12 == other.c12 && 
    c20 == other.c20 && c21 == other.c21 && c22 == other.c22;

  requires [1\100]boardPerm();
  pure int boardCount() = 0
    + (c00 != -1 ? 1 : 0)
    + (c01 != -1 ? 1 : 0)
    + (c02 != -1 ? 1 : 0)
    + (c10 != -1 ? 1 : 0)
    + (c11 != -1 ? 1 : 0)
    + (c12 != -1 ? 1 : 0)
    + (c20 != -1 ? 1 : 0)
    + (c21 != -1 ? 1 : 0)
    + (c22 != -1 ? 1 : 0)
    ;
      
  context Perm(move,1) ** Perm(myMark, 1\2);
  context [1\100]boardPerm();
  ensures move != null;
  ensures move.state();
  ensures move.mark == myMark;
  requires !boardFull();
  ensures readMoveCell(move,this) == -1;
  void createNewMove();

}

requires Perm(move.i,read) ** Perm(move.j,read);
requires 0 <= move.i && move.i <= 2;
requires 0 <= move.j && move.j <= 2;
requires [1\100]p.boardPerm();
pure int readMoveCell(Move move, Player p) =
  (move.i == 0 && move.j == 0) ? p.c00
  : (move.i == 0 && move.j == 1) ? p.c01
  : (move.i == 0 && move.j == 2) ? p.c02
  : (move.i == 1 && move.j == 0) ? p.c10
  : (move.i == 1 && move.j == 1) ? p.c11
  : (move.i == 1 && move.j == 2) ? p.c12
  : (move.i == 2 && move.j == 0) ? p.c20
  : (move.i == 2 && move.j == 1) ? p.c21
  : p.c22;
